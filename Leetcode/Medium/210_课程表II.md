# Leetcode ：210.课程表

## 一、题目链接
# 示例：[LeetCode 210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/description/)

## 二、题目描述
寻找到一个能学习完所有课程的路线，即寻找有向无环图，拓扑图序


## 三、解题思路与代码实现
### 1. 核心思路
使用深度优先算法或者广度优先算法：
    深度优先：
        使用 0 ，1 ，2 分别表示为搜索，搜索中和搜索完成，随机遍历节点，当遍历无下一节点压入栈中，在搜索过程中如果重新到了状态为1的节点，说明有环，无法修完全部课程，最后将栈倒置返回。
    广度优先：
        使用入度作为标识，当某个节点的入度为0时即没有先修课程时加入队列，在遍历队列头中课程能下一个修的课程，直到队列为空，直接将队列弹出的值到答案中。


### 2. 代码实现
```C++
# 深度优先算法：
class Solution {
private:
    vector<vector<int>> edge;
    vector<int> visited;
    bool valid;
    stack<int> st;
    vector<int> answer;
    void dfs(int u)
    {
        visited[u] = 1;
        for( auto course : edge[u] )
        {
            if( visited[course] == 0 )
            {
                dfs(course);
                if(!valid)
                    return;
            }
            else if( visited[course] == 1)
            {
                valid =  false;
                return;
            }
        }
        st.push(u);
        visited[u] = 2;
    }
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        valid = true;
        edge.resize(numCourses);
        visited.resize(numCourses);
        for(auto course : prerequisites)
        {
            edge[course[1]].push_back(course[0]);
        }
        for(int i = 0; i < numCourses && valid ; ++i)
        {
            if(!visited[i])
                dfs(i);
        }
        while(!st.empty() && valid)
        {
            answer.push_back(st.top());
            st.pop();
        }
        return answer;
    }
};


#广度优先算法：
class Solution {
private:
    vector<vector<int>> edge;
    vector<int> indeg;
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        edge.resize(numCourses);
        indeg.resize(numCourses);
        vector<int> answer;
        for(auto course : prerequisites)
        {
            edge[course[1]].push_back(course[0]);
            indeg[course[0]] ++;
        }

        queue<int> q;        
        int visited = 0;
        for(int i = 0; i < numCourses; ++i)
        {
            if(indeg[i] == 0)
            {
                 q.push(i);
                 visited++;
            }
        }

        while(!q.empty())
        {
            int cur = q.front();
            answer.push_back(q.front());
            q.pop();
            for( auto course : edge[cur])
            {
                indeg[course]--;
                if(indeg[course] == 0 )
                {
                    visited++;
                    q.push(course);
                }
            }
        }
        vector<int> cuo = {};
        return visited == numCourses ? answer : cuo;
    }
};
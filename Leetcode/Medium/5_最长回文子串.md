# Leetcode ：5.最长回文子串

## 一、题目链接
# [5.最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/)

## 二、题目描述
寻找字符串中最长的回文串

## 三、解题思路与代码实现
### 1. 核心思路
1. 动态规划：
    1. 使用DP数组存储，i和j表示i到j下标的子串为回文
    2. 先遍历长度，在遍历起始下标
    3. 当当前的两个字符相等时，如果长度小于等于三，直接设置当前状态为真，否则将上一个状态dp[i+1][j-1]转移而来
2. 中心扩展法：
    1. 定义一个扩散函数，返回以传入的边界左右扩散开来，直到找到最长的回文串的左右边界
    2. 遍历字符串传入一个字符或者当前字符和下一个字符

### 2. 代码实现
#### 动态规划：
```C++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if( n < 2 ) return s; 
        vector<vector<int>> dp(n, vector<int>(n));
        int begin = 0 , maxLen = 1;
        for( int len = 2; len <= n ; len++) {
            for( int i = 0 ; i < n ; i++) {
                int j = i + len - 1;
                if( j >= n ) break;

                if( s[i] != s[j] ) dp[i][j] = false;
                else {
                    if( len <= 3  ) dp[i][j] = true;
                    else {
                        dp[i][j] = dp[i+1][j-1];
                    }
                }

                if( dp[i][j] && len > maxLen ) {
                    begin = i;
                    maxLen = len;
                }
            }
        }
        return s.substr(begin, maxLen);
    }
};
```
- 时间复杂度：O(n^2)
- 空间复杂度：O(n^2)

#### 中心扩散法：
```C++
class Solution {
private:
    pair<int, int> expandCenter(const string &s, int left, int right) {
        while( left >=0 && right < s.size() && s[left] == s[right] )
        {
            left--;
            right++;
        }
        return {left + 1, right - 1}; 
    }
public:
    string longestPalindrome(string s) {
        int len = s.size();
        if( len < 2 ) return s;
        int start = 0 , end = 0;
        for( int i = 0 ; i < len ; i++) {
            auto [left1, right1] = expandCenter(s, i, i);
            auto [left2, right2] = expandCenter(s, i, i + 1);

            if( right1 - left1 > end - start ) {
                start = left1;
                end =  right1;
            }

            if( right2 - left2 > end - start ) {
                start = left2;
                end =  right2;
            }
        }
        return s.substr(start, end - start + 1);
    }
};
```
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)
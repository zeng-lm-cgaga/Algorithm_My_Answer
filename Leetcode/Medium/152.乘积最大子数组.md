# Leetcode ：152.乘积最大子数组

## 一、题目链接
# [152.乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/?envType=study-plan-v2&envId=top-100-liked)

## 二、题目描述
找到数组中的乘积最大的子数组

## 三、解题思路与代码实现
### 1. 核心思路
- 动态规划：
    - 状态表示：因为有负数，不能直接从上一个状态直接转换而来，所以需要维护两个数组，最大和最小数组，可以优化成两个变量
    - 状态初始化：将最大值，最小值，答案都初始化为数组的第一个数
    - 状态转换：下一个最大值由当前最大值乘上当前元素，当前最小值乘上当前元素和当前元素的最大值，而下一个最小值是这些的最小值，将答案和转换后最大值比较，最后返回答案

### 2. 代码实现
#### 动态规划：
```C++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        long maxF = nums[0], minF = nums[0], ans = nums[0];
        for (int i = 1; i < nums.size(); ++i) {
            long mx = maxF, mn = minF;
            maxF = max(mx * nums[i], max((long)nums[i], mn * nums[i]));
            minF = min(mn * nums[i], min((long)nums[i], mx * nums[i]));
            if(minF<INT_MIN) {
                minF=nums[i];
            }
            ans = max(maxF, ans);
        }
        return ans;
    }
};
```
- 时间复杂度：O(n)
- 空间复杂度：O(1)
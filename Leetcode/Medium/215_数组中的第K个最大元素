# Leetcode ：215.数组中的第K个最大元素

## 一、题目链接
# [LeetCode 215.数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)

## 二、题目描述
在无序的数组中寻找第K大的元素


## 三、解题思路与代码实现
### 1. 核心思路
1. 快速选择（快排）:
    1. 定义三个数组small、equal、big，分别存放与基准值（随机获取）比较后的元素，
    2. 然后根据容器的大小，如果big数组大小大于k，说明目标元素就在big数组，如果nums.size() - small.size() < k ，
        说明目标元素在small里，否则就在equal里，直接返回基准值

2. 堆排序 ：


### 2. 代码实现
```C++
# 快排算法：
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        return quickQuery(nums, k);
    }
private:
    int quickQuery(vector<int> nums, int k ) {
        vector<int> small, equal, big;
        int pivot = nums[rand() % nums.size()];
        for( auto num : nums )
        {
            if( num <  pivot ) small.push_back(num);
            else if(num == pivot ) equal.push_back(num);
            else big.push_back(num);
        }

        if( big.size() >= k ) return quickQuery(big, k);
        else if( nums.size() - small.size() < k ) return quickQuery(small, k + small.size() - nums.size());
        else 
            return pivot; 
    }
};

#堆排序：
class Solution {
private:
    void maxHeapify(vector<int>& heap, int i, int heapsize) {
        int left = i * 2 + 1, right = i * 2  + 2, largest =i;
        if( left < heapsize && heap[left] > heap[largest]) largest = left;
        if( right < heapsize && heap[right] > heap[largest]) largest = right;
        if( largest != i ) {
            swap(heap[i], heap[largest]);
            maxHeapify(heap, largest, heapsize);
        }
    }
    void buildMaxHeap(vector<int>& heap, int heapsize) {
        for(int i = heapsize / 2 - 1; i >= 0 ; --i) 
        {
            maxHeapify(heap, i, heapsize);
        }
    }
public:
    int findKthLargest(vector<int>& nums, int k) {
        int heapsize = nums.size();
        buildMaxHeap(nums, heapsize);
        for( int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {
            swap(nums[0], nums[i]);
            --heapsize;
            maxHeapify(nums, 0 , heapsize);
        }
        return nums[0];
    }
};
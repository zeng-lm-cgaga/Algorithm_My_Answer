# Leetcode ：207.课程表

## 一、题目链接
# [LeetCode 207. 课程表](https://leetcode.cn/problems/course-schedule/?envType=study-plan-v2&envId=top-100-liked)

## 二、题目描述
寻找到一个能学习完所有课程的路线，即寻找有向无环图，拓扑图序


## 三、解题思路与代码实现
### 1. 核心思路
使用深度优先算法或者广度优先算法：
    深度优先：
        使用 0 ，1 ，2 分别表示为搜索，搜索中和搜索完成，在搜索过程中如果重新到了状态为1的节点，说明有环，无法修完全部课程，直接返回false，最后程序结束返回valid。
    广度优先：
        使用入度作为标识，当某个节点的入度为0时即没有先修课程时加入队列，在遍历队列头中课程能下一个修的课程，直到队列为空。


### 2. 代码实现
#### 深度优先算法：

```C++
class Solution {
private:
    vector<vector<int>> edge;
    vector<int> visited;
    bool valid;
    void dfs(int u)
    {
        visited[u] = 1;
        for( auto course : edge[u] )
        {
            if( visited[course] == 0 )
            {
                dfs(course);
                if(!valid)
                    return;
            }
            else if( visited[course] == 1)
            {
                valid =  false;
                return;
            }
        }
        visited[u] = 2;
    }
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        valid = true;
        edge.resize(numCourses);
        visited.resize(numCourses);
        for(auto course : prerequisites)
        {
            edge[course[1]].push_back(course[0]);
        }
        for(int i = 0; i < numCourses && valid ; ++i)
        {
            if(!visited[i])
                dfs(i);
        }
        return valid;
    }
};

```
#### 广度优先算法：
```C++

class Solution {
private:
    vector<vector<int>> edge;
    vector<int> indeg;
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        edge.resize(numCourses);
        indeg.resize(numCourses);
        for(auto course : prerequisites)
        {
            edge[course[1]].push_back(course[0]);
            indeg[course[0]] ++;
        }

        queue<int> q;        
        int visited = 0;
        for(int i = 0; i < numCourses; ++i)
        {
            if(indeg[i] == 0)
            {
                 q.push(i);
                 visited++;
            }
        }

        while(!q.empty())
        {
            int cur = q.front();
            q.pop();
            for( auto course : edge[cur])
            {
                indeg[course]--;
                if(indeg[course] == 0 )
                {
                    visited++;
                    q.push(course);
                }
            }
        }
        return visited == numCourses;
    }
};
```
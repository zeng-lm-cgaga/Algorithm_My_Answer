# Leetcode ：912.排序数组

## 一、题目链接
# [LeetCode 912.排序数组](https://leetcode.cn/problems/sort-an-array/description/)

## 二、题目描述
将数组排序

## 三、解题思路与代码实现
### 1. 核心思路
1. 快排算法:
    1. 首先需要确定基准值，必须要随机生成（使用srand(time(NULL))获取随机树种子，防止固定伪随机数列）。
    2. 将基准值与子数组第一个元素互换，防止干扰后面排序
    3. 排序时交换元素后两个光标都要移动，防止有多个相同值的元素不断互换，导致死循环。
    4. 不断拆分数组直到排序完毕
2. 堆排序：
    1. 首先建堆，从最后一个非叶子节点开始，并且交换了父子节点的话还要到对替换的子节点进行下称
    2. 建好堆之后进行len-1次调整即排序，将堆顶元素与最后一个叶子元素互换，且数组长度减一即排好了一个数，避免再次排序
3. 归并排序：
    1. 创建一个临时数组且长度为传入数组的长度
    2. 首先递归将数组分割为长度为一的数组，然后状态返回将递归的数组进行合并排序，使用临时数组存储
    3. 在每次递归最后将临时数组的值与原数组的值互换

### 2. 代码实现
#### 快排算法：
```C++

class Solution {
private:
    int partition(vector<int>& nums, int left, int right) {
        int i = left + rand() % (right - left + 1);
        int pivot = nums[i];
        swap(nums[i], nums[left]);
        i = left + 1;
        int j = right;
        while(true) {
            while( i <= j && nums[i] < pivot) i++;
            while( j >= i && nums[j] > pivot) j--;
            if( i >= j ) break;
            swap(nums[i], nums[j]); 
            i++;
            j--;
        }
        swap(nums[left], nums[j]);
        return j;
    }
    void quickSort(vector<int>& nums, int left, int right) {
        bool sorted = true;
        for( int i = left + 1; i <= right ; ++i ) {
            if( nums[i] < nums[i-1]) {
                sorted = false;
                break;
            }
        }
        if(sorted) return;
        int pivot = partition(nums, left, right);
        quickSort(nums, left, pivot - 1);
        quickSort(nums, pivot + 1, right);
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        srand(time(NULL));
        quickSort(nums, 0, nums.size() - 1);
        return nums;
    }
};
```
- 时间复杂度：期望为O(nlogn)
- 空间复杂度：期望为O(logn)
#### 堆排序：
```C++
class Solution {
private:
    void maxHeapify(vector<int>& nums, int index, int len) {
        while( index * 2 + 1 <= len ) {
            int large = index;
            int left = index * 2 + 1, right = index * 2 + 2;

            if( left <= len && nums[left] > nums[large] ) large = left;
            if( right <= len && nums[right] > nums[large] ) large = right;

            if( large != index ) {
                swap(nums[large], nums[index]);
                index = large;
            }
            else {
                break;
            }
        }
    }

    void buildMaxheap(vector<int>& nums, int len) {
        for( int i = len / 2 ; i >=0 ; --i) {
            maxHeapify(nums, i, len);
        }
    }

    void heapSort(vector<int>& nums) {
        int len = nums.size() - 1;
        buildMaxheap(nums, len);
        for( int i = len ; i > 0  ; --i) {
            swap(nums[i], nums[0]);
            len--;
            maxHeapify(nums, 0, len);
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        heapSort(nums);
        return nums;
    }
};
```
- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)

#### 归并排序：
```C++
class Solution {
private:
    vector<int> tmp;
    void mergeSort(vector<int>& nums, int left, int right) {
        if( left >= right) return;
        int mid = ( left + right ) / 2;
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        int i = left , j = mid + 1;
        int cnt = 0;
        while(i <= mid && j <= right ) {
            if( nums[i] <= nums[j] ) 
                tmp[cnt++] = nums[i++];

            else tmp[cnt++] = nums[j++];
        }
        while(i <= mid) {
            tmp[cnt++] = nums[i++];
        }
        while( j <= right ) tmp[cnt++] = nums[j++];

        for(int i = 0 ; i < right - left + 1 ; ++i) {
            nums[i+left] = tmp[i];
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        tmp.resize(nums.size(), 0);
        mergeSort(nums, 0, nums.size() - 1);
        return nums;
    }
};
```
- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)


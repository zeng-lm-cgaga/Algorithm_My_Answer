# Leetcode ：300.最长递增子序列

## 一、题目链接
# [300.最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)

## 二、题目描述
找到数组中的最长递增子序列

## 三、解题思路与代码实现
### 1. 核心思路
- 动态规划：
    - 状态表示：表示以该下标以及之前的元素能组成的最长长度的递增子序列
    - 状态初始化：每一位都设置为1，因为都是一个长度为1的递增子序列
    - 状态转换：先遍历物品即元素，再遍历背包，从物品的下标开始到结尾，看谁能与该物品递增组合且进行状态转换

- 贪心+二分：
    - 状态数组表示：建立一个数组，表示最长递增子序列的该下标的最小的元素
    - 二分查找，如果当前元素大于当前len的末尾元素，则len++且插入到状态数组中，小于的话，则再状态数组中查找比当前元素小的最大值，并且插入到他的后面
### 2. 代码实现
#### 动态规划：
```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int result = 1;
        vector<int> dp(nums.size() + 1, 1 );
        for( int i = 0; i < nums.size(); ++i ) {
            for( int j = i+1; j < nums.size(); ++j) {
                if( nums[j] > nums[i] ) 
                    dp[j] = max(dp[j], dp[i] + 1);
                if( dp[j] > result ) result = dp[j];
            } 
        }
        return result;
    }
};
```
- 时间复杂度：O(n^2)
- 空间复杂度：O(n)

#### 贪心+二分：
```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int len = 1, n = nums.size();
        if( n == 0 ) return 0;
        vector<int> dp(n + 1, 0);
        dp[len] = nums[0];
        for( int i = 1; i < n; ++i ) {
            if( nums[i] > dp[len] ) {
                dp[++len] = nums[i];
            } else {
                int l = 1, r = len, pos = 0;
                while( l <= r) {
                    int mid = (l + r) / 2;
                    if( nums[i] > dp[mid] ) {
                        pos = mid;
                        l = mid + 1;
                    }
                    else {
                        r = mid - 1;
                    }
                }
                dp[pos + 1] = nums[i];
            }
        }
        return len;
    }
};
```
- 时间复杂度：O(nlog(n))
- 空间复杂度：O(n)


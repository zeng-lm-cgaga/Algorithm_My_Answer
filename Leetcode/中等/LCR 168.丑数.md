# Leetcode ：LCR 168.丑数

## 一、题目链接
# [LCR 168.丑数](https://leetcode.cn/problems/chou-shu-lcof/description/?envType=problem-list-v2&envId=GzFbGrmM)

## 二、题目描述
寻找第n个丑数
丑数：只包含质因数 2 、3 、5 的正整数

## 三、解题思路与代码实现
### 1. 核心思路
- 哈希表+小根堆：维护一个小根堆，每次将栈顶元素出栈，并且将站栈顶元素乘2 、3 、5并且在哈希表中没有出现，然后压入小根堆中

- 动态规划：定义三个指针 ftr2, ftr3, ftr5​，表示下一个丑数是当前指针指向的丑数乘对应的质因数，且当前状态值等于这三个乘数的最小值。初始时，三个指针的值都是 1
    分别比较乘后的数是否等于当前dp状态值，相等则使指针+1，这样能保证每次得到得丑数都会是最小的那个并且没有重复

### 2. 代码实现
#### 哈希表+小根堆：
```C++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> factors = { 2 , 3 , 5};
        unordered_set<long> seen;
        priority_queue<long, vector<long>, greater<long>> heap;
        seen.insert(1L);
        heap.push(1L);
        int ugly = 0;
        for(int i = 0; i < n; ++i ) {
            long cur = heap.top();
            heap.pop();
            ugly = (int)cur;
            for( auto factor : factors) {
                long next = cur * factor;
                if( !seen.count(next)) {
                    seen.insert(next);
                    heap.push(next);
                }
            }
        }
        return ugly;
    }
};
```
- 时间复杂度：O(nlog n)
- 空间复杂度：O(n)

#### 动态规划：
```C++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n+1);
        dp[0]= 0;
        dp[1] = 1;
        int ftr2 = 1, ftr3 = 1, ftr5 = 1;
        for( int i = 2; i <= n ; ++i ) {
            dp[i] = min( dp[ftr2] * 2, min(dp[ftr3] * 3, dp[ftr5] * 5));
            if( dp[i] == dp[ftr2] * 2) ftr2++;
            if( dp[i] == dp[ftr3] * 3) ftr3++;
            if( dp[i] == dp[ftr5] * 5) ftr5++;
        }
        return dp[n];
    }
};
```
- 时间复杂度：O(n)
- 空间复杂度：O(n)
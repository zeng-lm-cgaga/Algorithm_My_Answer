# LCR 183.望远镜中最高的海拔

## 一、题目链接
# [LCR 183.望远镜中最高的海拔](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/description/?envType=problem-list-v2&envId=GzFbGrmM)

## 二、题目描述
在有限的距离中找其中的最大值

## 三、解题思路与代码实现
### 1. 核心思路
- 滑动窗口：
    - 优先队列：维护一个大根堆（优先队列），并且在每次 插入元素的时候都判断堆顶元素是不是在该滑动窗口中
    - 单调队列：维护一个递减单调队列，将元素插入时将队列中小于该元素的值都从队尾弹出，并且判断队头的元素是否在滑动窗口中
### 2. 代码实现
#### 优先队列：
```C++
class Solution {
public:
    vector<int> maxAltitude(vector<int>& heights, int limit) {
        int n = heights.size();
        if( n==0 ) return {};
        priority_queue<pair<int, int>> q;
        for( int i = 0; i < limit; ++i ) {
            q.emplace(heights[i], i);
        }
        vector<int> ans = {q.top().first};
        for( int i = limit; i < n; ++i ) {
            q.emplace(heights[i], i);
            while( q.top().second <= i - limit )
                q.pop();
            ans.emplace_back(q.top().first);
        } 
        return ans;
    }
};
```
- 时间复杂度：O(N logN)
- 空间复杂度：O(N)
#### 单调队列：
```C++
class Solution {
public:
    vector<int> maxAltitude(vector<int>& heights, int limit) {
        int n = heights.size();
        if( n==0 ) return {};
        deque<int> q;
        for( int i = 0; i < limit; ++i ) {
            while( !q.empty() && heights[q.back()] <= heights[i] )
                q.pop_back();
            q.push_back(i);
        }
        vector<int> ans = {heights[q.front()]};
        for( int i = limit; i < n; ++i ) {
            while( !q.empty() && heights[q.back()] <= heights[i] )
                q.pop_back();
            q.push_back(i);
            while(q.front() <= i - limit)
                q.pop_front();
            ans.push_back(heights[q.front()]);
        }
        return ans;
    }
};
```
- 时间复杂度：O(N)
- 空间复杂度：O(limit)

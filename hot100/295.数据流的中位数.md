# Leetcode ：295.数据流的中位数

## 一、题目链接
# [LeetCode 295.数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/description/?envType=study-plan-v2&envId=top-100-liked)

## 二、题目描述
定义一个随时能找到中位数的类

## 三、解题思路与代码实现
### 1. 核心思路
- 大根堆与小根堆：
    使用大根堆存储数组的左半边（leftHeap），小根堆(rightHeap)存储数组的右半边，保证左堆的大小 >= 右堆的大小，且插值不超过一。
    - 插入的两种情况：
        1. 当两个堆数量相等时，先插入当前值插入右堆，在将右堆的堆顶值插入到左堆并弹出右堆的堆顶值
        2. 不相等时，即左堆个数大于右堆，则先插入左堆，在将左堆的堆顶值插入到右堆并弹出左堆堆顶值
    - 保证了右堆的大小都大于左堆，且个数插值不超过1
    - 答案两种情况：
        1. 数组大小为偶数，即左堆大小等于右堆大小，则中位数等于左堆的最大值和右堆的最小值相加除以2.
        2. 数组大小为奇数时，即为左堆最大值，即堆顶值


### 2. 代码实现
#### 大根堆和小根堆：
```C++
class MedianFinder {
private:
    // 大顶堆：存储较小的一半元素（堆顶是左半部分最大值）
    priority_queue<int, vector<int>, less<int>> leftHeap;
    // 小顶堆：存储较大的一半元素（堆顶是右半部分最小值）
    priority_queue<int, vector<int>, greater<int>> rightHeap;

public:
    MedianFinder() {}
    
    void addNum(int num) {
        // 第一步：保证堆的平衡（左堆大小 ≥ 右堆大小，且差值不超过1）
        if (leftHeap.size() == rightHeap.size()) {
            // 左堆需要多一个元素：先加入右堆，再把右堆顶（最小的大值）移到左堆
            rightHeap.push(num);
            leftHeap.push(rightHeap.top());
            rightHeap.pop();
        } else {
            // 右堆需要补一个元素：先加入左堆，再把左堆顶（最大的小值）移到右堆
            leftHeap.push(num);
            rightHeap.push(leftHeap.top());
            leftHeap.pop();
        }
    }
    
    double findMedian() {
        // 总元素数为奇数：左堆顶就是中位数
        if (leftHeap.size() > rightHeap.size()) {
            return static_cast<double>(leftHeap.top());
        }
        // 总元素数为偶数：左右堆顶的平均值
        return (static_cast<double>(leftHeap.top()) + rightHeap.top()) / 2.0;
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```

